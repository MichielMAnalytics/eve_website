{"ast":null,"code":"var _jsxFileName = \"/Users/hidde/Documents/Landingpage/components/AnimatedLines.js\";\nimport React, { useEffect, useRef, useState } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SEGMENT_LENGTH = 25;\nconst SNAKE_LENGTH = 35;\nconst SPEED = 4;\nconst MAX_TURNS = 3;\nconst MIN_SPAWN_DELAY = 2000;\nconst MAX_SPAWN_DELAY = 5000;\nconst MAX_ACTIVE_SNAKES = 8;\nconst MIN_ACTIVE_SNAKES = 3;\nconst AnimatedLines = () => {\n  const screenWidth = Dimensions.get('window').width;\n  const screenHeight = Dimensions.get('window').height;\n  const [snakes, setSnakes] = useState([]);\n  const createSnake = () => ({\n    id: Math.random(),\n    dots: Array(SNAKE_LENGTH).fill(0).map(() => ({\n      x: new Animated.Value(-SEGMENT_LENGTH),\n      y: new Animated.Value(0)\n    })),\n    direction: {\n      x: 1,\n      y: 0\n    },\n    position: {\n      x: -SEGMENT_LENGTH,\n      y: Math.random() * screenHeight * 0.8 + screenHeight * 0.1\n    },\n    path: [],\n    turnsRemaining: MAX_TURNS,\n    lastTurnX: -SEGMENT_LENGTH\n  });\n  useEffect(() => {\n    setSnakes([createSnake(), createSnake(), createSnake()]);\n    const spawnSnake = () => {\n      setSnakes(current => {\n        const activeSnakes = current.filter(snake => snake.position.x <= screenWidth + SEGMENT_LENGTH);\n        if (activeSnakes.length < MIN_ACTIVE_SNAKES) {\n          return [...activeSnakes, createSnake()];\n        } else if (activeSnakes.length < MAX_ACTIVE_SNAKES) {\n          return [...activeSnakes, createSnake()];\n        }\n        return activeSnakes;\n      });\n      const delay = MIN_SPAWN_DELAY + Math.random() * (MAX_SPAWN_DELAY - MIN_SPAWN_DELAY);\n      setTimeout(spawnSnake, delay);\n    };\n    const initialDelay = MIN_SPAWN_DELAY + Math.random() * (MAX_SPAWN_DELAY - MIN_SPAWN_DELAY);\n    setTimeout(spawnSnake, initialDelay);\n  }, []);\n  useEffect(() => {\n    const moveSnakes = () => {\n      setSnakes(current => current.map(snake => {\n        snake.position.x += snake.direction.x * SPEED;\n        snake.position.y += snake.direction.y * SPEED;\n        snake.path.push(Object.assign({}, snake.position));\n        if (snake.path.length > SNAKE_LENGTH) {\n          snake.path.shift();\n        }\n        const distanceSinceLastTurn = Math.abs(snake.position.x - snake.lastTurnX);\n        if (snake.turnsRemaining > 0 && distanceSinceLastTurn > SEGMENT_LENGTH * 8 && Math.random() < 0.003) {\n          const directions = [{\n            x: 1,\n            y: 0\n          }, {\n            x: 0,\n            y: 1\n          }, {\n            x: 0,\n            y: -1\n          }];\n          const availableDirections = directions.filter(d => d.x !== snake.direction.x || d.y !== snake.direction.y);\n          snake.direction = availableDirections[Math.floor(Math.random() * availableDirections.length)];\n          snake.turnsRemaining--;\n          snake.lastTurnX = snake.position.x;\n        }\n        snake.dots.forEach((dot, index) => {\n          const pathPoint = snake.path[Math.max(0, snake.path.length - 1 - index)] || snake.position;\n          dot.x.setValue(pathPoint.x);\n          dot.y.setValue(pathPoint.y);\n        });\n        return snake;\n      }));\n      requestAnimationFrame(moveSnakes);\n    };\n    moveSnakes();\n  }, []);\n  return _jsxDEV(View, {\n    style: styles.container,\n    children: snakes.map(snake => _jsxDEV(View, {\n      children: snake.dots.map((dot, index) => _jsxDEV(Animated.View, {\n        style: [styles.dot, {\n          opacity: (SNAKE_LENGTH - index) / SNAKE_LENGTH * 0.3,\n          transform: [{\n            translateX: dot.x\n          }, {\n            translateY: dot.y\n          }]\n        }]\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 13\n      }, this))\n    }, snake.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 112,\n    columnNumber: 5\n  }, this);\n};\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    pointerEvents: 'none'\n  },\n  dot: {\n    position: 'absolute',\n    width: 4,\n    height: 4,\n    backgroundColor: '#F4E409',\n    borderRadius: 2\n  }\n});\nexport default AnimatedLines;","map":{"version":3,"names":["React","useEffect","useRef","useState","View","Animated","StyleSheet","Dimensions","jsxDEV","_jsxDEV","SEGMENT_LENGTH","SNAKE_LENGTH","SPEED","MAX_TURNS","MIN_SPAWN_DELAY","MAX_SPAWN_DELAY","MAX_ACTIVE_SNAKES","MIN_ACTIVE_SNAKES","AnimatedLines","screenWidth","get","width","screenHeight","height","snakes","setSnakes","createSnake","id","Math","random","dots","Array","fill","map","x","Value","y","direction","position","path","turnsRemaining","lastTurnX","spawnSnake","current","activeSnakes","filter","snake","length","delay","setTimeout","initialDelay","moveSnakes","push","Object","assign","shift","distanceSinceLastTurn","abs","directions","availableDirections","d","floor","forEach","dot","index","pathPoint","max","setValue","requestAnimationFrame","style","styles","container","children","opacity","transform","translateX","translateY","fileName","_jsxFileName","lineNumber","columnNumber","create","top","left","right","bottom","pointerEvents","backgroundColor","borderRadius"],"sources":["/Users/hidde/Documents/Landingpage/components/AnimatedLines.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport { View, Animated, StyleSheet, Dimensions } from 'react-native';\n\nconst SEGMENT_LENGTH = 25;\nconst SNAKE_LENGTH = 35;\nconst SPEED = 4;\nconst MAX_TURNS = 3;\nconst MIN_SPAWN_DELAY = 2000;  // Minimum time between spawns (ms)\nconst MAX_SPAWN_DELAY = 5000;  // Maximum time between spawns (ms)\nconst MAX_ACTIVE_SNAKES = 8;   // Maximum number of snakes on screen\nconst MIN_ACTIVE_SNAKES = 3;   // Minimum number of snakes on screen\n\nconst AnimatedLines = () => {\n  const screenWidth = Dimensions.get('window').width;\n  const screenHeight = Dimensions.get('window').height;\n  const [snakes, setSnakes] = useState([]);\n  \n  const createSnake = () => ({\n    id: Math.random(),  // Unique identifier\n    dots: Array(SNAKE_LENGTH).fill(0).map(() => ({\n      x: new Animated.Value(-SEGMENT_LENGTH),\n      y: new Animated.Value(0),\n    })),\n    direction: { x: 1, y: 0 },\n    position: { x: -SEGMENT_LENGTH, y: Math.random() * screenHeight * 0.8 + screenHeight * 0.1 },\n    path: [],\n    turnsRemaining: MAX_TURNS,\n    lastTurnX: -SEGMENT_LENGTH,\n  });\n\n  useEffect(() => {\n    // Initial snakes\n    setSnakes([createSnake(), createSnake(), createSnake()]);\n\n    // Spawn new snakes randomly\n    const spawnSnake = () => {\n      setSnakes(current => {\n        // Remove off-screen snakes\n        const activeSnakes = current.filter(\n          snake => snake.position.x <= screenWidth + SEGMENT_LENGTH\n        );\n        \n        // Add new snake if below minimum or if below maximum\n        if (activeSnakes.length < MIN_ACTIVE_SNAKES) {\n          return [...activeSnakes, createSnake()];\n        } else if (activeSnakes.length < MAX_ACTIVE_SNAKES) {\n          return [...activeSnakes, createSnake()];\n        }\n        return activeSnakes;\n      });\n\n      // Schedule next spawn\n      const delay = MIN_SPAWN_DELAY + Math.random() * (MAX_SPAWN_DELAY - MIN_SPAWN_DELAY);\n      setTimeout(spawnSnake, delay);\n    };\n\n    // Start spawning\n    const initialDelay = MIN_SPAWN_DELAY + Math.random() * (MAX_SPAWN_DELAY - MIN_SPAWN_DELAY);\n    setTimeout(spawnSnake, initialDelay);\n  }, []);\n\n  useEffect(() => {\n    const moveSnakes = () => {\n      setSnakes(current => \n        current.map(snake => {\n          // Update head position\n          snake.position.x += snake.direction.x * SPEED;\n          snake.position.y += snake.direction.y * SPEED;\n\n          // Store path point\n          snake.path.push({ ...snake.position });\n          if (snake.path.length > SNAKE_LENGTH) {\n            snake.path.shift();\n          }\n\n          // Change direction with limitations\n          const distanceSinceLastTurn = Math.abs(snake.position.x - snake.lastTurnX);\n          if (snake.turnsRemaining > 0 && \n              distanceSinceLastTurn > SEGMENT_LENGTH * 8 &&\n              Math.random() < 0.003) {\n            const directions = [\n              { x: 1, y: 0 },\n              { x: 0, y: 1 },\n              { x: 0, y: -1 },\n            ];\n            const availableDirections = directions.filter(d => \n              d.x !== snake.direction.x || d.y !== snake.direction.y\n            );\n            snake.direction = availableDirections[Math.floor(Math.random() * availableDirections.length)];\n            snake.turnsRemaining--;\n            snake.lastTurnX = snake.position.x;\n          }\n\n          // Update dot positions\n          snake.dots.forEach((dot, index) => {\n            const pathPoint = snake.path[Math.max(0, snake.path.length - 1 - index)] || snake.position;\n            dot.x.setValue(pathPoint.x);\n            dot.y.setValue(pathPoint.y);\n          });\n\n          return snake;\n        })\n      );\n\n      requestAnimationFrame(moveSnakes);\n    };\n\n    moveSnakes();\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      {snakes.map((snake) => (\n        <View key={snake.id}>\n          {snake.dots.map((dot, index) => (\n            <Animated.View\n              key={index}\n              style={[\n                styles.dot,\n                {\n                  opacity: (SNAKE_LENGTH - index) / SNAKE_LENGTH * 0.3,\n                  transform: [\n                    { translateX: dot.x },\n                    { translateY: dot.y },\n                  ],\n                },\n              ]}\n            />\n          ))}\n        </View>\n      ))}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    pointerEvents: 'none',\n  },\n  dot: {\n    position: 'absolute',\n    width: 4,\n    height: 4,\n    backgroundColor: '#F4E409',\n    borderRadius: 2,\n  },\n});\n\nexport default AnimatedLines; "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}